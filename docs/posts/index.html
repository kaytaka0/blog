<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://www.kaytaka.com/posts/"><meta property="og:site_name" content="k-taka"><meta property="og:title" content="k-taka"><meta property="og:locale" content="en"><meta property="og:type" content="website"><title>Posts | k-taka</title>
<link rel=icon href=https://www.kaytaka.com/favicon.png><link rel=manifest href=https://www.kaytaka.com/manifest.json><link rel=canonical href=https://www.kaytaka.com/posts/><link rel=stylesheet href=https://www.kaytaka.com/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=https://www.kaytaka.com/fuse.min.js></script><script defer src=https://www.kaytaka.com/en.search.min.43ac1410281d6401802182199ac5b7b703523217e77c1b125307dbd3dd0c9bb9.js integrity="sha256-Q6wUECgdZAGAIYIZmsW3twNSMhfnfBsSUwfb090Mm7k=" crossorigin=anonymous></script><script defer src=https://www.kaytaka.com/sw.min.88f1afdaf4798d7d3520420dcfe201f928c3d371fdedfc3ae28cd9b6b79544f8.js integrity="sha256-iPGv2vR5jX01IEINz+IB+SjD03H97fw64ozZtreVRPg=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://www.kaytaka.com/posts/index.xml title=k-taka></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=https://www.kaytaka.com/><span>k-taka</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=https://www.kaytaka.com/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul><li><a href=https://www.kaytaka.com/ru/>Russian</a></li><li><a href=https://www.kaytaka.com/zh/>Chinese</a></li></ul></li></ul><ul><li><a href=https://github.com/alex-shpak/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://www.kaytaka.com/svg/menu.svg class=book-icon alt=Menu></label><h3>Posts</h3><label for=toc-control><img src=https://www.kaytaka.com/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/get_gcp_domain/>Google Domainsで取得したドメインの更新</a></h2><div class=book-post-content><h1 id=google-domainsで取得したドメインの更新>Google Domainsで取得したドメインの更新
<a class=anchor href=#google-domains%e3%81%a7%e5%8f%96%e5%be%97%e3%81%97%e3%81%9f%e3%83%89%e3%83%a1%e3%82%a4%e3%83%b3%e3%81%ae%e6%9b%b4%e6%96%b0>#</a></h1><p>2021年にGoogle Domainsで取得したドメインの有効期限が過ぎていたので，自分のブログサイトが閲覧できない状態になっていた．
もちろんブログサイト自体は稼働し続けているため，ブラウザのURL欄にIPを打ち込めば閲覧することはできる．
しかし，せっかく一度取得したドメインを失効したままにするのは格好が悪いため，ドメイン有効期限の更新を行う．</p><p>Google Domainsでは,年額￥850から独自ドメインを取得することができる．(2022年3月時点)</p><p>今回更新したドメイン<code>kazapps.info</code>では，年額￥1,400（税別）であった．
独自ドメインの料金については，公式ページから検索することができる．
<a href=https://domains.google/>Google Domains</a></p><h2 id=更新手順>更新手順
<a class=anchor href=#%e6%9b%b4%e6%96%b0%e6%89%8b%e9%a0%86>#</a></h2><p>更新手順は非常にシンプル.</p><ul><li>Googleからドメイン有効期限のお知らせメールが来ている場合</li></ul><p>Googleから通知メールが来ている場合には，リンクをクリックすることで直接クレジットカード決済の画面に行くことができる．
今回は，1年間だけ有効期限を延長したいので，「年を追加」をクリックし，クレジットカード決済の確認を行う．</p><p><img src=https://www.kaytaka.com/img/domain-expired-mail.png alt=domain-expired-mail></p><ul><li>Google Domains管理ページから更新を行う場合</li></ul><p>Google Domains管理ページの「マイドメイン>管理」ページにアクセスすると，次のような表示が出ている．
1年間だけ有効期限を延長したいので，「年を追加」からクレジットカード決済の画面に遷移する．</p><p><img src=https://www.kaytaka.com/img/google-domains.png alt=google-domains></p><p>「年を追加」をクリックするとクレジットカード決済の画面に移動する．
<img src=https://www.kaytaka.com/img/domain-update.png alt=domain-update></p><p>ブログサイトではサブドメイン (blog.kazapps.info) を利用しているため，DNSレコードの登録が必要だが，
今回は既に登録済みなので作業の必要はなかった．
Google Domainsでは，有効期限が切れていても一定期間はドメインの設定を残してくれていたため助かった．
ただし，一定期間が過ぎるとドメインは削除される．<br>以下はGoogle Domainsからのメール通知の内容</p><blockquote><p>ドメインの更新は28日以内に行なってください．この期間を過ぎると，Googleのシステムからドメインが削除されます．</p></blockquote><p>有効期限が過ぎた後の対応は以下のページにまとまっていた．</p><ul><li><a href="https://support.google.com/domains/answer/3260599?hl=ja">Google Domainsヘルプ: ドメイン登録の有効期限と削除</a></li></ul><p>ざっくり次の様になっている</p><table><thead><tr><th>有効期限が切れてからの日数</th><th>状態</th></tr></thead><tbody><tr><td>1-30日目</td><td>更新猶予期間．ドメイン登録の更新には追加料金はかからない．</td></tr><tr><td>31-60日目</td><td>ドメイン名の復元は可能だが，追加の料金がかかる</td></tr><tr><td>61日目</td><td>Googleに連絡がない場合，ドメインは削除．他の人が購入できる様になる．</td></tr></tbody></table></div></article><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/mini-container/>Linux namespaces+cgroupによる簡易コンテナの自作</a></h2><div class=book-post-content><h1 id=linux-namespacescgroupによる簡易コンテナの自作>Linux namespaces+cgroupによる簡易コンテナの自作
<a class=anchor href=#linux-namespacescgroup%e3%81%ab%e3%82%88%e3%82%8b%e7%b0%a1%e6%98%93%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%ae%e8%87%aa%e4%bd%9c>#</a></h1><p>最近，仮想化技術 (VMM, NFV, コンテナ等) について勉強をはじめました．
仮想化に関連する技術の中でも，普段から開発，実験でよく利用しているDocker (コンテナ型仮想化) について，理解を深めるために，簡易なコンテナの実装を行いました．
今回実装する上で，参考にした記事がこちらです．</p><p><a href=https://kaminashi-developer.hatenablog.jp/entry/dive-into-swamp-container-scratch>「【Go言語】自作コンテナ沼。スクラッチでミニDockerを作ろう - カミナシ開発者ブログ」</a></p><p>コンテナを実現するために使用される基礎技術のみに絞って実装，解説を行なっており，コンテナ技術の本質部分を理解するための非常に良いチュートリアルだと感じました．
これをきっかけに自作コンテナ沼にハマっていきたいと思います．</p><h2 id=githubリポジトリ>Githubリポジトリ
<a class=anchor href=#github%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa>#</a></h2><p>Golangで実装したコンテナ作成コマンドはこちらのGithubリポジトリで公開しています．</p><p><a href=https://github.com/takashimakazuki/mini-container>https://github.com/takashimakazuki/mini-container</a></p><h2 id=実装した機能>実装した機能
<a class=anchor href=#%e5%ae%9f%e8%a3%85%e3%81%97%e3%81%9f%e6%a9%9f%e8%83%bd>#</a></h2><p>簡易コンテナということで，実装した機能は非常に単純です．
コンテナを作成し，作成したコンテナ内で指定したコマンドを実行するというものになります．
プログラム内でやっていることは以下です．</p><ul><li>Linux namespace機能を用いた実行環境の隔離。つまりコンテナ化を行う。</li><li>chrootによってファイルシステムを分離</li><li>cgroupを使ってコンテナが使える計算リソースを制限する</li><li>コンテナプロセス内でのコマンド実行</li></ul></div></article><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/ovs/>Open vSwitchとDocker でネットワークの勉強</a></h2><div class=book-post-content><h1 id=open-vswitch-と-docker-でネットワークの勉強>Open vSwitch と Docker でネットワークの勉強
<a class=anchor href=#open-vswitch-%e3%81%a8-docker-%e3%81%a7%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e3%81%ae%e5%8b%89%e5%bc%b7>#</a></h1><p>マスタリングTCP/IPを一通り読んだので，実際にIPv4ネットワークがどのように動作しているのか手を動かしながら確認したいと思いました．
本記事で作成するネットワークでは，仮想ルータ４台に手作業でルーティングテーブルを設定することで，それぞれに対してパケットを送受信できることを目指しました．
今回はルーティングテーブルの手動設定を初めて体験したいという軽い気持ちで始めたため，ルータ+L2スイッチの実機を用意することは考えずに，仮想環境で実行します．</p><h2 id=環境>環境
<a class=anchor href=#%e7%92%b0%e5%a2%83>#</a></h2><ul><li>Apple M1 Mac(ホストマシン)</li><li>UTM: VM(仮想マシン)を立ち上げるソフトウェア<ul><li>Linux上で動作検証したかったため</li></ul></li><li>Ubuntu 18.04 Server</li><li>Docker<ul><li><code>CentOS7 on docker</code>のルーティングテーブルを用いてルーティングを行う</li></ul></li><li>Open vSwitch<ul><li>オープンソースの仮想スイッチソフトウェア</li></ul></li></ul><h2 id=ネットワーク構成図>ネットワーク構成図
<a class=anchor href=#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e6%a7%8b%e6%88%90%e5%9b%b3>#</a></h2><p>今回作成したいネットワーク構成図</p><p><img src=https://www.kaytaka.com/img/ovs-network.png alt=network></p><h2 id=静的ルーティングの設定>静的ルーティングの設定
<a class=anchor href=#%e9%9d%99%e7%9a%84%e3%83%ab%e3%83%bc%e3%83%86%e3%82%a3%e3%83%b3%e3%82%b0%e3%81%ae%e8%a8%ad%e5%ae%9a>#</a></h2><p>Dockerコンテナ内でルーティングテーブルの設定を行う．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route add <span style=color:#f92672>[</span>ネットワーク部の指定<span style=color:#f92672>]</span> via <span style=color:#f92672>[</span>転送先IPの指定<span style=color:#f92672>]</span> dev <span style=color:#f92672>[</span>デバイス名<span style=color:#f92672>]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec router1 ip route add 10.0.3.0/24 via 10.0.1.2 dev eth0  <span style=color:#75715e># router1-&gt;router4(10.0.3.2)</span>
</span></span><span style=display:flex><span>docker exec router2 ip route add 10.0.4.0/24 via 10.0.3.2 dev eth1  <span style=color:#75715e># router2-&gt;router3(10.0.4.1)</span>
</span></span><span style=display:flex><span>docker exec router3 ip route add 10.0.1.0/24 via 10.0.2.1 dev eth0  <span style=color:#75715e># router3-&gt;router2(10.0.1.2)</span>
</span></span><span style=display:flex><span>docker exec router4 ip route add 10.0.2.0/24 via 10.0.4.1 dev eth1  <span style=color:#75715e># router4-&gt;router1(10.0.2.1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker exec router1 ip route add 10.0.4.0/24 via 10.0.2.2 dev eth1
</span></span><span style=display:flex><span>docker exec router2 ip route add 10.0.2.0/24 via 10.0.1.1 dev eth0
</span></span><span style=display:flex><span>docker exec router3 ip route add 10.0.3.0/24 via 10.0.4.2 dev eth1
</span></span><span style=display:flex><span>docker exec router4 ip route add 10.0.1.0/24 via 10.0.3.1 dev eth0
</span></span></code></pre></div><h2 id=githubリポジトリ>Githubリポジトリ
<a class=anchor href=#github%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa>#</a></h2><p>OVSのブリッジ作成スクリプトとDockerfile</p><a href=https://www.kaytaka.com/posts/ovs/>...</a></div></article><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/kos-01-07/>OS自作本　進捗0x01</a></h2><div class=book-post-content><h1 id=ゼロからのos自作入門作業記録>ゼロからのOS自作入門　作業記録
<a class=anchor href=#%e3%82%bc%e3%83%ad%e3%81%8b%e3%82%89%e3%81%aeos%e8%87%aa%e4%bd%9c%e5%85%a5%e9%96%80%e4%bd%9c%e6%a5%ad%e8%a8%98%e9%8c%b2>#</a></h1><p>内田公太氏の「ゼロからのOS自作入門」でのOS作成作業を記録として記す。</p><h2 id=228-第1章>2/28 第1章
<a class=anchor href=#228-%e7%ac%ac1%e7%ab%a0>#</a></h2><p>開発環境の構築</p><p>自作OSの開発に利用した環境</p><ul><li>ThinkCentre M720s Small</li><li>Ubuntu 20.04 Focal Fossa</li></ul><p>動作確認は、仮想マシンのqemuを使用する。
BOOTX64.EFIというファイルにバイナリを打ち込んで、起動する。gitに完成済みのEFIファイルがあるが、初めての作業なのでoctetaで一つずつ１６進数を打ち込むことにした。
qemuで「Hello, workd」を表示できた。</p><p><img src=https://www.kaytaka.com/img/kos/kos-d1-hello-world.png alt=hello-world></p><p>C言語で同じ動作をするEFIファイルを作成する。
Cプログラム→（コンパイラ clang）→オブジェクトファイル→ (リンカ lld-link) → EFIファイル(hello.efi)</p><h2 id=31第2章>3/1　第2章
<a class=anchor href=#31%e7%ac%ac2%e7%ab%a0>#</a></h2><p>EDKⅡを利用してアプリケーション開発ができるようにする。
まずはEDKでのハローワールドから始める。</p><p>EDKⅡ：UEFI BIOS上で動作するアプリケーション開発キット</p><p>２章を読んだのみで実装は進まなかった。</p><h2 id=34-第2章>3/4 第2章
<a class=anchor href=#34-%e7%ac%ac2%e7%ab%a0>#</a></h2><p>EDKでハローワールド
KosLoaderPkg/以下にLoad.inf, Main.c, KosLoaderPkg.dec, KosLoaderPkg.decの４ファイルを作成し、EDKを用いてビルドを行う
→Loader.efiが生成されるため、これをBOOTX64.EFIとして保存する。(run_qemu.shで実行できる)</p><p>実行結果：edkでハローワールド(めっちゃ誤字している)
<img src=https://www.kaytaka.com/img/kos/kos-d2-edk-hello.png alt=edk-hello></p><p>今後このアプリケーションをブートローダとして拡張していく</p><p>まずはメモリマップの取得を行う。</p><p>edkで用意されている機能<code>gBS->GetMemoryMap</code>を使用する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>EFI_STATUS <span style=color:#a6e22e>GetMemoryMap</span>(
</span></span><span style=display:flex><span>    IN OUT UINTN <span style=color:#f92672>*</span>MemoryMapSize,
</span></span><span style=display:flex><span>    IN OUT EFI_MEMORY_DSCRIPTOR <span style=color:#f92672>*</span>Memorymap,
</span></span><span style=display:flex><span>    OUT UINTN <span style=color:#f92672>*</span>MapKey,
</span></span><span style=display:flex><span>    OUT UINTN <span style=color:#f92672>*</span>DescriptorSize,
</span></span><span style=display:flex><span>    OUT UINT32 <span style=color:#f92672>*</span>DescriptorVersion
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li>MemoryMapSize：MemoryMapのバッファサイズ（出力は実際のメモリサイズ）</li><li>MemoryMap: メモリマップ書き込み先のメモリ領域の先頭ポインタ</li><li>MapKey：メモリマップを識別するための値を書き込む変数を指定する</li><li>DescriptorSize: メモリマップの個々の行を表すメモリディスクリプタのバイト数</li><li>DescriptorVersion: メモリディスクリプタ構造体のバージョン番号（使用しない）</li></ul><p>メモリマップの読み込み成功。下図はメモリディスクリプタの各要素csvファイルとして出力している。</p><a href=https://www.kaytaka.com/posts/kos-01-07/>...</a></div></article><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/seccon2022/>SECCON CTF 2022 Writeup 'koncha'[pwn]</a></h2><div class=book-post-content><h1 id=seccon-ctf-2022-writeup-konchapwn>SECCON CTF 2022 Writeup &lsquo;koncha&rsquo;[pwn]
<a class=anchor href=#seccon-ctf-2022-writeup-konchapwn>#</a></h1><p>2022年11月に開催されたSECCON2022予選に参加しました．
おそらく日本で一番有名かつ大規模なCTF大会ということもあり，非常に面白い問題（そして難しい問題）が多く，
競技時間の24時間は必死に問題に取り組むことができ楽しかったです．</p><p>本記事では，競技時間中にFLAGを見つけることができたpwnの問題についてメモを残します．</p><h2 id=問題>問題
<a class=anchor href=#%e5%95%8f%e9%a1%8c>#</a></h2><a href=https://www.kaytaka.com/posts/seccon2022/seccon2022-koncha.png><img src=https://www.kaytaka.com/posts/seccon2022/seccon2022-koncha_hu_3d8169b1277747b.png alt=koncha></a><p>tar.gzファイルを展開すると，問題のC言語ファイル，バイナリ，libc，ローカル実行環境構築用のDockerfileなどがあります．</p><h2 id=解法>解法
<a class=anchor href=#%e8%a7%a3%e6%b3%95>#</a></h2><p>C言語ファイルの重要な部分を抜き出すと，以下のようになります．</p><p><code>name</code>, <code>country</code>変数を定義して，1回目のscanfでnameに入力値を格納，printfでnameを出力．
2回目のscanfでcountryに入力値を格納，printfでcountryを出力するという非常にシンプルなプログラムです．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>0x30</span>], country[<span style=color:#ae81ff>0x20</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%[^</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>]s&#34;</span>, name);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Nice to meet you, %s!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, name);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, country);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Wow, %s is such a nice country!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, country);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>また，各種セキュリティ機構は以下のようになっています．64bitでcanaryなし，PIE (Position Independent Executables) ありです．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ checksec ./chall
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> <span style=color:#e6db74>&#39;chall&#39;</span>
</span></span><span style=display:flex><span>    Arch:     amd64-64-little
</span></span><span style=display:flex><span>    RELRO:    Partial RELRO
</span></span><span style=display:flex><span>    Stack:    No canary found
</span></span><span style=display:flex><span>    NX:       NX enabled
</span></span><span style=display:flex><span>    PIE:      PIE enabled
</span></span></code></pre></div><p>このプログラムの脆弱性は，2回行われるscanfに入力文字数の制限がないことです．
これにより，スタックオーバーフローを起こすことができます．</p><a href=https://www.kaytaka.com/posts/seccon2022/>...</a></div></article><article class="markdown book-post"><h2><a href=https://www.kaytaka.com/posts/tenable-pwnable/>Tenable CTF 2022 Writeup 'Olden Ring'[pwn]</a></h2><div class=book-post-content><h1 id=tenable-ctf-2022-writeup-olden-ringpwn>Tenable CTF 2022 Writeup &lsquo;Olden Ring&rsquo;[pwn]
<a class=anchor href=#tenable-ctf-2022-writeup-olden-ringpwn>#</a></h1><p>この記事では，CTF (Capture the Flag) オンライン大会の
<a href=https://tenable.ctfd.io/scoreboard>Tenable CTF 2022</a>で取り組んだ問題の解説をおこないます．</p><p>Tenable CTFには，研究室のメンバー3名でチームを作って挑戦しました．
私が取り組んだ問題は，pwnの&rsquo;Olden Ring&rsquo;です．
ポイントは100ptsと一番低い分類にあたるので，pwn初心者問題だと思われます．</p><h2 id=問題>問題
<a class=anchor href=#%e5%95%8f%e9%a1%8c>#</a></h2><p>netcatで接続するためのリモートサーバのIP,ポート番号の情報と，oldenというファイルが添付されている．</p><p>fileコマンドでファイルの内容を調べたところ，64bitのELFバイナリファイルであることはわかりました．</p><h2 id=解説>解説
<a class=anchor href=#%e8%a7%a3%e8%aa%ac>#</a></h2><p>ファイルを実行してみる（または，netcatでリモートサーバに接続してみる）と，どうやらコマンドラインのゲームらしいです．（問題名から察するに，ELDEN RING風のゲームなのかも？？）
いくつかの説明文とともに，コマンドラインで入力が求められるというものでした．</p><p>バイナリファイルをGhidraを使ってデコンパイルした結果，main関数の他にdefeat_frog_guys関数，boss_fight関数があることがわかります．</p><p>その他の関数として，どの関数からも呼び出されていない<code>zip_to_end</code>関数があり，flag.txtの内容を出力する処理を行なっています．
つまり，最終的にこの関数を実行することができれば，フラグを取得できるはず．</p><p>脆弱性を探す上で，ユーザからの入力を受け付けている関数の使い方に誤りがないかをチェックしていきました．
すると，fgets関数がバッファサイズを指定して使われていることがわかります．ユーザ入力の格納先は<code>local_418</code> (Ghidraのデコンパイル時に自動生成された変数名) という変数でした．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>fgets</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>local_418, <span style=color:#ae81ff>0x400</span>, stdin);
</span></span></code></pre></div><p>変数local_418はローカル変数なので，BOFできればmain関数のreturnアドレス書き換えが可能です．
しかし，どうやらこの変数local_418のバッファサイズは0x400はあるようで，fgetsによってBOFできそうには見えませんでした．</p><p>main関数内で，変数local_418から0x400バイト分0で埋めることによって初期化しているため，バッファサイズが0x400バイトあることは想定されているようです．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>local_418, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x400</span>);
</span></span></code></pre></div><p>変数local_418が利用されている箇所を中心に，他の処理をチェックしてみます．</p><p>defeat_frog_guysという関数の引数として変数local_418 (ユーザ文字列のバッファ) が利用されているため，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// local_418が利用されている！
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>defeat_frog_guys</span>(<span style=color:#f92672>&amp;</span>local_418, local_14);
</span></span></code></pre></div><p>このdefeat_frog_guys関数では，memcpy等を用いて，データのコピーが行われているようでした．
コピーの流れが複雑なため，ソースコードから挙動を理解するのに時間がかかると判断したため，ここからはGDBによってプログラムを実行させながら挙動を把握していきました．</p><p>ユーザが入力した文字列は，defeat_frog_guys関数のスタックフレーム内にコピーされているようでした．
そこで，ためしに&rsquo;AAAAA&mldr;&lsquo;という長さ0x400の文字列を入力したところ，<code>Segmentation fault</code>が発生し，BOFが発生したことを確認できました！
defeat_frog_guys関数のスタックがBOF可能ということがわかったので，あとはdefeat_frog_guys→mainに戻る際のreturnアドレスを書き換えて，zip_to_end関数の先頭アドレスにすれば完了です．</p><ol><li>zip_to_end関数のアドレス：0x4012b6（ASLR，PIE等のセキュリティ機構はオフになっているのでアドレスは固定でした）</li><li>returnアドレス書き換えのためのパディングの長さ：0x3f3バイト</li><li>２回目のfgetsで入力する数値：199</li></ol><p>２回目のfgetsで入力する数値によって，コピーされる場所が何バイトかずれたりするようで，上記の2と3については，
何度か入力する数値，パディングの長さを変えてGDBを実行しました．
GDBではプログラム実行中にブレークポイントを設置して，プログラムのある時点でのスタックの内容を表示することができるため，この機能を使うことでパディングの長さを調整しました．
使用したGDBのコマンドは主に以下のようなものです．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>// ブレークポイントを設置する
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> break 0x400000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 現在のスタックtopから40x8バイト分のデータを表示する．
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/40gx $rsp 
</span></span></code></pre></div><p>最終的に，以下のコマンドを実行することでexploitコードが出力されます．
これをリモートサーバのプログラムの入力として与えることでフラグが手に入ります．</p><a href=https://www.kaytaka.com/posts/tenable-pwnable/>...</a></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/31f6364621221779c31a7427ea6f5aa86b605432 title='Last modified by k-takashima | March 18, 2022' target=_blank rel=noopener><img src=https://www.kaytaka.com/svg/calendar.svg class=book-icon alt>
<span>March 18, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/posts/_index.md target=_blank rel=noopener><img src=https://www.kaytaka.com/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul></ul></li></ul></nav></div></aside></main></body></html>